# 什么是 `no_std`

在 Rust 开发时，有时需要使用 `!#[no_std]` 属性，
不把 `std` 库链接到程序中。
那么，什么是 `no_std`，在什么情况下我们一定要使用 `no_std`?

嵌入式编程，通常分为两大类：

- Hosted Environments: 与普通 PC 环境类似，环境中包含一个系统接口（如 POSIX），提供了各种系统（文件系统、网络、内存管理、线程）交互的操作。标准库依赖这些操作实现其功能。
- Bare Metal Environments: 在裸机环境中，程序加载前没有加载任何代码。此时，无法加载标准库，程序和 crates 只能使用硬件/裸机运行。标准库的平台无关部分通过 libcore 提供。

总的来说，在 Bare Metal 环境中开发嵌入式软件，一定要使用 `no_std`。
但是，libstd 到底提供了什么？

使用 `libstd` 需要某种系统集成，
但这并不仅是因为 `libstd` 只是提供了一个访问 OS 抽象的通用方式，
它还提供了一个运行时。
这个运行时负责设置堆栈溢出保护、处理命令行参数，并在程序的主函数被调用之前启动主线程。
在 `no_std` 中，这些操作都需要自己处理。

|feature|no_std|std|
|-------|:----:|:-:|
|堆（动态内存）|[^1]|✓|
|集合（Vec、BTreeMap 等）|[^2]|✓|
|栈溢出保护|X|✓|
|在 main 之前运行初始化代码|X|✓|

[^1]: 需要使用 `alloc` crate, 指定内存分配器。
[^2]: 缺少安全的随机数生成器，HashMap 和 HashSet 不可用。

`no_std` 也可以在需要使用 `std` 的程序中发挥作用。
nom 解析器组合库确保解析器（通常位于程序的“热点”路径）不会发生任何分配对于性能来说非常有用。
